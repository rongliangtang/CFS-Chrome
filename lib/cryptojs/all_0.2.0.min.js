/*
 * The MIT License
 *
 * (MIT)Copyright (c) 2015 artjomb
 */
!function(t) {
    t.enc.Bin = {
        stringify: function(t) {
            for (var e = t.words, r = t.sigBytes, i = [], n = 0; r > n; n++)
                for (var o = e[n >>> 2] >>> 24 - n % 4 * 8 & 255, s = 7; s >= 0; s--)
                    i.push((o >>> s & 1).toString(2));
            return i.join("")
        },
        parse: function(e) {
            for (var r = [0], i = 31, n = 0, o = 0; o < e.length; o++) {
                var s = e[o];
                ("0" === s || "1" === s) && (r[r.length - 1] += parseInt(s) << i,
                i--,
                n++,
                0 > i && (i = 31,
                r.push(0)))
            }
            return t.lib.WordArray.create(r, Math.ceil(n / 8))
        }
    }
}(CryptoJS),
function(t) {
    var e;
    e = t.hasOwnProperty("ext") ? t.ext : t.ext = {},
    e.bitshift = function(t, e) {
        var r, i, n = 0, o = t.words, s = 0;
        if (e > 0) {
            for (; e > 31; )
                o.splice(0, 1),
                o.push(0),
                e -= 32,
                s++;
            if (0 == e)
                return n;
            for (var c = o.length - s - 1; c >= 0; c--)
                r = o[c],
                o[c] <<= e,
                o[c] |= n,
                n = r >>> 32 - e
        } else if (0 > e) {
            for (; -31 > e; )
                o.splice(0, 0, 0),
                o.length--,
                e += 32,
                s++;
            if (0 == e)
                return n;
            e = -e,
            i = (1 << e) - 1;
            for (var c = s; c < o.length; c++)
                r = o[c] & i,
                o[c] >>>= e,
                o[c] |= n,
                n = r << 32 - e
        }
        return n
    }
    ,
    e.neg = function(t) {
        for (var e = t.words, r = 0; r < e.length; r++)
            e[r] = ~e[r];
        return t
    }
    ,
    e.xor = function(t, e) {
        for (var r = 0; r < t.words.length; r++)
            t.words[r] ^= e.words[r];
        return t
    }
    ,
    e.bitand = function(t, e) {
        for (var r = t.clone(), i = r.words, n = e.words, o = 0; o < i.length; o++)
            i[o] &= n[o];
        return r
    }
}(CryptoJS),
function(t) {
    var e = t.lib.WordArray
      , r = window.crypto
      , i = Int32Array;
    i && r && r.getRandomValues ? e.random = function(t) {
        var n = new i(Math.ceil(t / 4));
        return r.getRandomValues(n),
        new e.init([].map.call(n, function(t) {
            return t
        }),t)
    }
    : console.log("No cryptographically secure randomness source available")
}(CryptoJS),
CryptoJS.mode.CFBw = function() {
    function t(t, e, r) {
        for (var i = this, n = i._cipher, o = n.blockSize, s = i._prevBlock, c = n.cfg.segmentSize / 32, a = 0; o / c > a; a++) {
            s ? s = s.slice(c).concat(i._ct) : (s = i._iv.slice(0),
            i._iv = void 0),
            r || (i._ct = t.slice(e + a * c, e + a * c + c));
            var f = s.slice(0);
            n.encryptBlock(f, 0);
            for (var u = 0; c > u; u++)
                t[e + a * c + u] ^= f[u];
            r && (i._ct = t.slice(e + a * c, e + a * c + c))
        }
        i._prevBlock = s
    }
    var e = CryptoJS.lib.BlockCipherMode.extend();
    return e.Encryptor = e.extend({
        processBlock: function(e, r) {
            t.call(this, e, r, !0)
        }
    }),
    e.Decryptor = e.extend({
        processBlock: function(e, r) {
            t.call(this, e, r, !1)
        }
    }),
    e
}(),
function(t) {
    var e;
    e = t.hasOwnProperty("ext") ? t.ext : t.ext = {};
    {
        var r = (t.lib.Base,
        t.lib.WordArray);
        t.algo.AES
    }
    e.const_Zero = r.create([0, 0, 0, 0]),
    e.const_One = r.create([0, 0, 0, 1]),
    e.const_Rb = r.create([0, 0, 0, 135]),
    e.const_Rb_Shifted = r.create([2147483648, 0, 0, 67]),
    e.const_nonMSB = r.create([4294967295, 4294967295, 2147483647, 2147483647]),
    e.isWordArray = function(t) {
        return t && "function" == typeof t.clamp && "function" == typeof t.concat && "array" == typeof t.words
    }
    ,
    t.pad.OneZeroPadding = {
        pad: function(t, e) {
            for (var i = 4 * e, n = i - t.sigBytes % i, o = [], s = 0; n > s; s += 4) {
                var c = 0;
                0 === s && (c = 2147483648),
                o.push(c)
            }
            var a = r.create(o, n);
            t.concat(a)
        },
        unpad: function() {}
    },
    t.pad.NoPadding = {
        pad: function() {},
        unpad: function() {}
    },
    e.leftmostBytes = function(t, e) {
        var r = t.clone();
        return r.sigBytes = e,
        r.clamp(),
        r
    }
    ,
    e.rightmostBytes = function(t, r) {
        t.clamp();
        var i = 32
          , n = t.clone()
          , o = 8 * (n.sigBytes - r);
        if (o >= i) {
            var s = Math.floor(o / i);
            o -= s * i,
            n.words.splice(0, s),
            n.sigBytes -= s * i / 8
        }
        return o > 0 && (e.bitshift(n, o),
        n.sigBytes -= o / 8),
        n
    }
    ,
    e.popWords = function(t, r) {
        var i = e.leftmostBytes(t, 4 * r);
        return t.words = t.words.slice(r),
        t.sigBytes -= 4 * r,
        i
    }
    ,
    e.shiftBytes = function(t, i) {
        i = i || 16;
        var n = i % 4;
        i -= n;
        for (var o = r.create(), s = 0; i > s; s += 4)
            o.words.push(t.words.shift()),
            t.sigBytes -= 4,
            o.sigBytes += 4;
        return n > 0 && (o.words.push(t.words[0]),
        o.sigBytes += n,
        e.bitshift(t, 8 * n),
        t.sigBytes -= n),
        o
    }
    ,
    e.xorendBytes = function(t, r) {
        return e.leftmostBytes(t, t.sigBytes - r.sigBytes).concat(e.xor(e.rightmostBytes(t, r.sigBytes), r))
    }
    ,
    e.dbl = function(t) {
        var r = e.msb(t);
        return e.bitshift(t, 1),
        1 === r && e.xor(t, e.const_Rb),
        t
    }
    ,
    e.inv = function(t) {
        var r = 1 & t.words[4];
        return e.bitshift(t, -1),
        1 === r && e.xor(t, e.const_Rb_Shifted),
        t
    }
    ,
    e.equals = function(t, e) {
        if (!e || !e.words || t.sigBytes !== e.sigBytes)
            return !1;
        t.clamp(),
        e.clamp();
        for (var r = 0; r < t.words.length; r++)
            if (t.words[r] !== e.words[r])
                return !1;
        return !0
    }
    ,
    e.msb = function(t) {
        return t.words[0] >>> 31
    }
}(CryptoJS),
CryptoJS.mode.CFBb = function() {
    function t(t, e, o) {
        var s, c, a, f = this, u = f._cipher, h = 32 * u.blockSize, l = f._prevBlock, p = u.cfg.segmentSize, d = [];
        for (s = 31; p > s; s += 32)
            d.push(4294967295);
        for (d.push((1 << p) - 1 << 32 - p),
        s = d.length; s < t.length; s++)
            d.push(0);
        d = r.create(d);
        var _, y = d.clone(), g = y.clone();
        for (i(g, 32 * -e),
        s = 0; h / p > s; s++) {
            if (l) {
                for (l = r.create(l),
                i(l, p),
                l = l.words,
                previousCiphertextSegment = f._ct; previousCiphertextSegment.length < h / 32; )
                    previousCiphertextSegment.push(0);
                previousCiphertextSegment = r.create(previousCiphertextSegment),
                i(previousCiphertextSegment, -h + p);
                for (var c = 0; c < l.length; c++)
                    l[c] |= previousCiphertextSegment.words[c]
            } else
                l = f._iv.slice(0),
                f._iv = void 0;
            a = 32 * e + s * p;
            var v = r.create(t.slice(0));
            i(v, a),
            o || (f._ct = v.words.slice(0, Math.ceil(p / 32)));
            var B = l.slice(0);
            for (u.encryptBlock(B, 0),
            c = 0; c < Math.ceil(p / 32); c++)
                v.words[c] ^= B[c];
            for (c = 0; c < v.words.length; c++)
                v.words[c] &= d.words[c];
            for (o && (f._ct = v.words.slice(0, Math.ceil(p / 32))),
            _ = n(g.clone()),
            c = 0; c < t.length; c++)
                t[c] &= _.words[c];
            for (i(v, -a),
            c = 0; c < t.length; c++)
                t[c] |= v.words[c];
            i(y, -p),
            i(g, -p)
        }
        f._prevBlock = l
    }
    var e = CryptoJS.lib.BlockCipherMode.extend()
      , r = CryptoJS.lib.WordArray
      , i = CryptoJS.ext.bitshift
      , n = CryptoJS.ext.neg;
    return e.Encryptor = e.extend({
        processBlock: function(e, r) {
            t.call(this, e, r, !0)
        }
    }),
    e.Decryptor = e.extend({
        processBlock: function(e, r) {
            t.call(this, e, r, !1)
        }
    }),
    e
}(),
function(t) {
    function e(e, r) {
        var o = n.createEncryptor(e, {
            iv: i.create(),
            padding: t.pad.NoPadding
        })
          , s = o.finalize(r);
        return s
    }
    var r = t.lib.Base
      , i = t.lib.WordArray
      , n = t.algo.AES
      , o = t.ext
      , s = t.pad.OneZeroPadding
      , c = t.algo.CMAC = r.extend({
        init: function(t) {
            var r = e(t, o.const_Zero)
              , i = r.clone();
            if (o.dbl(i),
            this._isTwo()) {
                var n = r.clone();
                o.inv(n)
            } else {
                var n = i.clone();
                o.dbl(n)
            }
            this._K1 = i,
            this._K2 = n,
            this._K = t,
            this._const_Bsize = 16,
            this.reset()
        },
        reset: function() {
            this._x = o.const_Zero.clone(),
            this._counter = 0,
            this._buffer = i.create()
        },
        update: function(r) {
            if (!r)
                return this;
            var i = this._buffer
              , n = this._const_Bsize;
            for ("string" == typeof r && (r = t.enc.Utf8.parse(r)),
            i.concat(r); i.sigBytes > n; ) {
                var s = o.shiftBytes(i, n);
                o.xor(this._x, s),
                this._x.clamp(),
                this._x = e(this._K, this._x),
                this._counter++
            }
            return this
        },
        finalize: function(t) {
            this.update(t);
            var r = this._buffer
              , i = this._const_Bsize
              , n = r.clone();
            return r.sigBytes === i ? o.xor(n, this._K1) : (s.pad(n, i / 4),
            o.xor(n, this._K2)),
            o.xor(n, this._x),
            this.reset(),
            e(this._K, n)
        },
        _isTwo: function() {
            return !1
        }
    });
    t.CMAC = function(t, e) {
        return c.create(t).finalize(e)
    }
    ,
    t.algo.OMAC1 = c,
    t.algo.OMAC2 = c.extend({
        _isTwo: function() {
            return !0
        }
    })
}(CryptoJS),
function(t) {
    {
        var e = t.lib.Base
          , r = t.lib.WordArray
          , i = (t.algo.AES,
        t.ext)
          , n = t.pad.OneZeroPadding
          , o = t.algo.CMAC
          , s = t.algo.S2V = e.extend({
            init: function(t) {
                this._blockSize = 16,
                this._cmacAD = o.create(t),
                this._cmacPT = o.create(t),
                this.reset()
            },
            reset: function() {
                this._buffer = r.create(),
                this._cmacAD.reset(),
                this._cmacPT.reset(),
                this._d = this._cmacAD.finalize(i.const_Zero),
                this._empty = !0,
                this._ptStarted = !1
            },
            updateAAD: function(e) {
                return this._ptStarted ? this : e ? ("string" == typeof e && (e = t.enc.Utf8.parse(e)),
                this._d = i.xor(i.dbl(this._d), this._cmacAD.finalize(e)),
                this._empty = !1,
                this) : this
            },
            update: function(e) {
                if (!e)
                    return this;
                this._ptStarted = !0;
                var r = this._buffer
                  , n = this._blockSize
                  , o = n / 4
                  , s = this._cmacPT;
                for ("string" == typeof e && (e = t.enc.Utf8.parse(e)),
                r.concat(e); r.sigBytes >= 2 * n; ) {
                    this._empty = !1;
                    var c = i.popWords(r, o);
                    s.update(c)
                }
                return this
            },
            finalize: function(t) {
                this.update(t);
                var e = this._blockSize
                  , r = this._buffer;
                if (this._empty && 0 === r.sigBytes)
                    return this._cmacAD.finalize(i.const_One);
                var o;
                return r.sigBytes >= e ? o = i.xorendBytes(r, this._d) : (n.pad(r, e),
                o = i.xor(i.dbl(this._d), r)),
                this._cmacPT.finalize(o)
            }
        });
        t.SIV = e.extend({
            init: function(t) {
                var e = t.sigBytes / 2;
                this._s2vKey = i.shiftBytes(t, e),
                this._ctrKey = t
            },
            encrypt: function(e, r) {
                !r && e && (r = e,
                e = []);
                var n = s.create(this._s2vKey);
                Array.prototype.forEach.call(e, function(t) {
                    n.updateAAD(t)
                });
                var o = n.finalize(r)
                  , c = i.bitand(o, i.const_nonMSB)
                  , a = t.AES.encrypt(r, this._ctrKey, {
                    iv: c,
                    mode: t.mode.CTR,
                    padding: t.pad.NoPadding
                });
                return o.concat(a.ciphertext)
            },
            decrypt: function(e, r) {
                !r && e && (r = e,
                e = []);
                var n = i.shiftBytes(r, 16)
                  , o = i.bitand(n, i.const_nonMSB)
                  , c = t.AES.decrypt({
                    ciphertext: r
                }, this._ctrKey, {
                    iv: o,
                    mode: t.mode.CTR,
                    padding: t.pad.NoPadding
                })
                  , a = s.create(this._s2vKey);
                Array.prototype.forEach.call(e, function(t) {
                    a.updateAAD(t)
                });
                var f = a.finalize(c);
                return i.equals(n, f) ? c : !1
            }
        })
    }
}(CryptoJS),
function(t) {
    {
        var e = t.lib.Base
          , r = t.lib.WordArray
          , i = t.algo.AES
          , n = t.ext
          , o = t.algo.CMAC
          , s = r.create([0, 0, 0, 0])
          , c = r.create([0, 0, 0, 1])
          , a = r.create([0, 0, 0, 2])
          , f = 16;
        t.EAX = e.extend({
            init: function(t, e) {
                var r;
                if (e && e.splitKey) {
                    var i = Math.floor(t.sigBytes / 2);
                    r = n.shiftBytes(t, i)
                } else
                    r = t.clone();
                this._ctrKey = t,
                this._mac = o.create(r),
                this._tagLen = e && e.tagLength || f,
                this.reset()
            },
            reset: function() {
                this._mac.update(c),
                this._ctr && this._ctr.reset()
            },
            updateAAD: function(t) {
                return this._mac.update(t),
                this
            },
            initCrypt: function(e, o) {
                var c = this;
                return c._tag = c._mac.finalize(),
                c._isEnc = e,
                c._mac.update(s),
                o = c._mac.finalize(o),
                n.xor(c._tag, o),
                c._ctr = i.createEncryptor(c._ctrKey, {
                    iv: o,
                    mode: t.mode.CTR,
                    padding: t.pad.NoPadding
                }),
                c._buf = r.create(),
                c._mac.update(a),
                c
            },
            update: function(e) {
                "string" == typeof e && (e = t.enc.Utf8.parse(e));
                var i = this
                  , o = i._buf
                  , s = i._isEnc;
                o.concat(e);
                var c = s ? o.sigBytes : Math.max(o.sigBytes - i._tagLen, 0)
                  , a = c > 0 ? n.shiftBytes(o, c) : r.create()
                  , f = i._ctr.process(a);
                return i._mac.update(s ? f : a),
                f
            },
            finalize: function(t) {
                var e = this
                  , i = t ? e.update(t) : r.create()
                  , o = e._mac
                  , s = e._ctr.finalize();
                if (e._isEnc) {
                    var c = o.finalize(s);
                    return n.xor(e._tag, c),
                    e.reset(),
                    i.concat(s).concat(e._tag)
                }
                var c = o.finalize();
                return n.xor(e._tag, c),
                e.reset(),
                n.equals(e._tag, e._buf) ? i.concat(s) : !1
            },
            encrypt: function(t, e, r) {
                var i = this;
                return r && Array.prototype.forEach.call(r, function(t) {
                    i.updateAAD(t)
                }),
                i.initCrypt(!0, e),
                i.finalize(t)
            },
            decrypt: function(t, e, r) {
                var i = this;
                return r && Array.prototype.forEach.call(r, function(t) {
                    i.updateAAD(t)
                }),
                i.initCrypt(!1, e),
                i.finalize(t)
            }
        })
    }
}(CryptoJS);
